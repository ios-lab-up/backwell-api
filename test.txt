JSON Test
{
  "courses":["Ética","Persona y sociedad"],
  "minimum":1
}
URL = https://localhost:8082/v1/api/generate_schedule


Check the following code of rust which should get combinations of possible subjects for schedules, the endpoint receives the arrangement of subjects that you want to take and the endpoint should return the possible combinations without the subjects are put on schedules for example if ethics is on Monday from 14:00 to 15: 30 and I want to put chemistry but the class is from 15:00 to 16:30 it could not be a possibility since they overlap for that is compared with other courses of chemistry or if there is not there then only send the schedule with a subject depending on which is the same minimum specified in the post, in the same way it verifies that the response of the endpoint the rust is in this way:
response (already does it)
data (already does it)
modify schedule
the arrangement of schedule of each subject instead of being key the day and value the hour that is by day, start date, end date, the point is to leave the response as friendly as possible to show the possible schedules in a simple way for the frontend.

In case the combinations fail do this:
Check the subject or all the subjects of the array are in the response, if the request to django is empty probably the subject does not exist or is misspelled then return a message of no open subjects were found or with that name or something similar, if a subject if this but for another no data came the same indicate that this subject was not found but return the search with the subject or subjects that if they are in the system.
In case of requesting two subjects and there is no combination and the minimum is two return spliced or overlapped subjects and that it is not possible, but if the minimum is 1 then send 2 possible schedules one with only one subject and another with only the other subject as it would be the possibility if the minimum selected is one.
Review filters and answers for possible situations similar to these and handle them in a way that always gives you the most options evaluating them well and in case there is not explain or return why.
Still change the generate path to /v1/api/generate....


response from django to rust with the courses, this request must be only of the selected subjects, not to make a get of everything since it is a lot of info, and since only the info of the subject that is wanted to register is needed, we must only obtain that one.

[
  {
    "id": 1,
    "materia": {
      "id": 1,
      "nombre": "Persona y sociedad",
      "no_de_catalogo": "    HUM002",
      "codigo": "FORHUM  "
    },
    "profesor": {
      "id": 1,
      "nombre": "Garcés Zapico,María del Carmen"
    },
    "schedules": [
      {
        "id": 1,
        "salon": {
          "id": 1,
          "nombre": "R 21",
          "capacidad": 35
        },
        "profesor": {
          "id": 1,
          "nombre": "Garcés Zapico,María del Carmen"
        },
        "dia": "Lunes",
        "hora_inicio": "16:00:00",
        "hora_fin": "18:30:00",
        "curso": 1
      },
      {
        "id": 2,
        "salon": {
          "id": 1,
          "nombre": "R 21",
          "capacidad": 35
        },
        "profesor": {
          "id": 1,
          "nombre": "Garcés Zapico,María del Carmen"
        },
        "dia": "Martes",
        "hora_inicio": "16:00:00",
        "hora_fin": "18:30:00",
        "curso": 1
      },
      {
        "id": 3,
        "salon": {
          "id": 1,
          "nombre": "R 21",
          "capacidad": 35
        },
        "profesor": {
          "id": 1,
          "nombre": "Garcés Zapico,María del Carmen"
        },
        "dia": "Miércoles",
        "hora_inicio": "16:00:00",
        "hora_fin": "18:30:00",
        "curso": 1
      },
      {
        "id": 4,
        "salon": {
          "id": 1,
          "nombre": "R 21",
          "capacidad": 35
        },
        "profesor": {
          "id": 1,
          "nombre": "Garcés Zapico,María del Carmen"
        },
        "dia": "Jueves",
        "hora_inicio": "16:00:00",
        "hora_fin": "18:30:00",
        "curso": 1
      },
      {
        "id": 5,
        "salon": {
          "id": 1,
          "nombre": "R 21",
          "capacidad": 35
        },
        "profesor": {
          "id": 1,
          "nombre": "Garcés Zapico,María del Carmen"
        },
        "dia": "Viernes",
        "hora_inicio": "16:00:00",
        "hora_fin": "18:00:00",
        "curso": 1
      }
    ],
    "horario": "Lunes 16:00 - 18:30 Martes 16:00 - 18:30 Miércoles 16:00 - 18:30 Jueves 16:00 - 18:30 Viernes 16:00 - 18:00",
    "id_del_curso": 29299,
    "ciclo": 1234,
    "sesion": "VER",
    "mat_comb": 38,
    "clases_comb": "1371,1417",
    "capacidad_inscripcion_combinacion": 20,
    "no_de_catalogo": "    HUM002",
    "clase": "Persona y sociedad            ",
    "no_de_clase": 1417,
    "capacidad_inscripcion": 9,
    "total_inscripciones": 6,
    "total_inscripciones_materia_combinada": 14,
    "fecha_inicial": "2023-06-19",
    "fecha_final": "2023-07-14",
    "bloque_optativo": "BLQ_10_BA ",
    "idioma_impartido": "",
    "modalidad_clase": ""
  },
  {
    "id": 2,
    "materia": {
      "id": 1,
      "nombre": "Persona y sociedad",
      "no_de_catalogo": "    HUM002",
      "codigo": "FORHUM  "
    },
    "profesor": {
      "id": 2,
      "nombre": "Pérez Treviño,Ariadne de Fátima"
    },
    "schedules": [
      {
        "id": 6,
        "salon": {
          "id": 2,
          "nombre": "R 28",
          "capacidad": 36
        },
        "profesor": {
          "id": 2,
          "nombre": "Pérez Treviño,Ariadne de Fátima"
        },
        "dia": "Lunes",
        "hora_inicio": "09:00:00",
        "hora_fin": "12:00:00",
        "curso": 2
      },
      {
        "id": 7,
        "salon": {
          "id": 2,
          "nombre": "R 28",
          "capacidad": 36
        },
        "profesor": {
          "id": 2,
          "nombre": "Pérez Treviño,Ariadne de Fátima"
        },
        "dia": "Martes",
        "hora_inicio": "09:00:00",
        "hora_fin": "12:00:00",
        "curso": 2
      },
      {
        "id": 8,
        "salon": {
          "id": 2,
          "nombre": "R 28",
          "capacidad": 36
        },
        "profesor": {
          "id": 2,
          "nombre": "Pérez Treviño,Ariadne de Fátima"
        },
        "dia": "Miércoles",
        "hora_inicio": "09:00:00",
        "hora_fin": "12:00:00",
        "curso": 2
      },
      {
        "id": 9,
        "salon": {
          "id": 2,
          "nombre": "R 28",
          "capacidad": 36
        },
        "profesor": {
          "id": 2,
          "nombre": "Pérez Treviño,Ariadne de Fátima"
        },
        "dia": "Jueves",
        "hora_inicio": "09:00:00",
        "hora_fin": "12:00:00",
        "curso": 2
      }
    ],
    "horario": "Lunes 09:00 - 12:00 Martes 09:00 - 12:00 Miércoles 09:00 - 12:00 Jueves 09:00 - 12:00",
    "id_del_curso": 29299,
    "ciclo": 1234,
    "sesion": "VER",
    "mat_comb": 37,
    "clases_comb": "1372,1418",
    "capacidad_inscripcion_combinacion": 20,
    "no_de_catalogo": "    HUM002",
    "clase": "Persona y sociedad            ",
    "no_de_clase": 1418,
    "capacidad_inscripcion": 7,
    "total_inscripciones": 3,
    "total_inscripciones_materia_combinada": 8,
    "fecha_inicial": "2023-06-19",
    "fecha_final": "2023-07-14",
    "bloque_optativo": "BLQ_10_BA ",
    "idioma_impartido": "",
    "modalidad_clase": ""
  },

  Esta response se puede filtrar con django filters
  import django_filters
from .models import Curso

class CursoFilter(django_filters.FilterSet):
    materia__nombre = django_filters.CharFilter(field_name='materia__nombre', lookup_expr='icontains')
    profesor__nombre = django_filters.CharFilter(field_name='profesor__nombre', lookup_expr='icontains')
    ciclo = django_filters.NumberFilter(field_name='ciclo', lookup_expr='exact')
    sesion = django_filters.CharFilter(field_name='sesion', lookup_expr='exact')

    class Meta:
        model = Curso
        fields = ['materia__nombre', 'profesor__nombre', 'ciclo', 'sesion']

Con esta informacion se puede cambiar el request de rust a django para que solo obtenga la informacion de las materias seleccionadas y no de todas las materias

// backwellApi/src/main.rs
use actix_web::{web, App, HttpServer, HttpResponse};
use serde::{Deserialize, Serialize};
use reqwest::Client;
use log::{info, error};
use std::collections::HashMap;
use std::env;
use url::Url;

mod schedule_utils;

#[derive(Deserialize)]
struct GenerateScheduleRequest {
    courses: Vec<String>,
    minimum: usize,
}

#[derive(Serialize)]
struct GenerateScheduleResponse {
    response: u16,
    data: Vec<Vec<CourseSchedule>>,
    schedule_s: HashMap<String, HashMap<String, HashMap<String, String>>>,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
struct CourseSchedule {
    id: i32,
    materia: Materia,
    profesor: Profesor,
    schedules: Vec<Schedule>,
    id_del_curso: i32,
    ciclo: i32,
    sesion: String,
    mat_comb: i32,
    clases_comb: String,
    capacidad_inscripcion_combinacion: i32,
    no_de_catalogo: String,
    clase: String,
    no_de_clase: i32,
    capacidad_inscripcion: i32,
    total_inscripciones: i32,
    total_inscripciones_materia_combinada: i32,
    fecha_inicial: String,
    fecha_final: String,
    bloque_optativo: String,
    idioma_impartido: Option<String>,
    modalidad_clase: String,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
struct Schedule {
    id: i32,
    salon: Salon,
    profesor: Profesor,
    dia: String,
    hora_inicio: String,
    hora_fin: String,
    curso: i32,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
struct Materia {
    id: i32,
    nombre: String,
    no_de_catalogo: Option<String>,
    codigo: Option<String>,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
struct Profesor {
    id: i32,
    nombre: String,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
struct Salon {
    id: i32,
    nombre: String,
    capacidad: Option<i32>,
}

async fn generate_schedule(req_body: web::Json<GenerateScheduleRequest>) -> impl actix_web::Responder {
    let client = Client::builder()
        .build()
        .expect("Failed to build HTTP client");

    let django_api_base_url = env::var("DJANGO_API_URL")
        .unwrap_or_else(|_| "http://web:8000/api/cursos/".to_string());

    let mut url = Url::parse(&django_api_base_url).expect("Invalid Django API URL");
    for course_name in &req_body.courses {
        url.query_pairs_mut()
            .append_pair("materia__nombre", course_name);
    }

    let response = client.get(url)
        .send()
        .await;

    let courses_data: Vec<CourseSchedule> = match response {
        Ok(resp) => {
            match resp.json().await {
                Ok(data) => data,
                Err(err) => {
                    error!("Error parsing response from Django API: {}", err);
                    return HttpResponse::InternalServerError()
                        .body(format!("Error parsing response from Django API: {}", err));
                }
            }
        },
        Err(err) => {
            error!("Error fetching data from Django API: {}", err);
            return HttpResponse::InternalServerError()
                .body(format!("Error fetching data from Django API: {}", err));
        }
    };

    let compatible_schedules = schedule_utils::create_compatible_schedules(
        &courses_data,
        &req_body.courses,
        req_body.minimum,
    );

    let schedule_s = simplify_schedules(&compatible_schedules);

    let response = GenerateScheduleResponse {
        response: 200,
        data: compatible_schedules,
        schedule_s,
    };

    HttpResponse::Ok().json(response)
}

// Simplifies the schedule for the `scheduleS` section
fn simplify_schedules(schedules: &Vec<Vec<CourseSchedule>>) -> HashMap<String, HashMap<String, HashMap<String, String>>> {
    let mut result = HashMap::new();

    for (i, schedule_group) in schedules.iter().enumerate() {
        let mut schedule_map = HashMap::new();
        for course in schedule_group {
            let mut days_map = HashMap::new();
            for sched in &course.schedules {
                let time_range = format!("{} - {}", sched.hora_inicio, sched.hora_fin);
                days_map.insert(sched.dia.clone(), time_range);
            }
            schedule_map.insert(course.materia.nombre.clone(), days_map);
        }
        result.insert(format!("horario{}", i + 1), schedule_map);
    }

    result
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    env_logger::init();
    let port = 8082;
    info!("Iniciando servidor en http://0.0.0.0:{}", port);

    HttpServer::new(|| {
        App::new()
            .route("/generate_schedule", web::post().to(generate_schedule))
    })
    .bind(("0.0.0.0", port))?
    .run()
    .await?;

    info!("Servidor Actix finalizado"); // Debe mantenerse activo
    Ok(())
}



// backwellApi/src/schedule_utils.rs

use crate::CourseSchedule;
use chrono::NaiveTime;
use petgraph::graph::{Graph, NodeIndex};
use petgraph::Undirected;
use std::collections::{HashMap, HashSet};

pub fn create_compatible_schedules(
    all_courses: &Vec<CourseSchedule>,
    course_names: &Vec<String>,
    _minimum: usize,
) -> Vec<Vec<CourseSchedule>> {
    let filtered_courses: Vec<&CourseSchedule> = all_courses.iter()
    .filter(|s| course_names.contains(&s.materia.nombre.trim().to_string()))
    .collect();

    let mut grouped_courses: HashMap<(String, i32), &CourseSchedule> = HashMap::new();
    for course in filtered_courses {
        let key = (course.materia.nombre.clone(), course.profesor.id);
        grouped_courses.insert(key.clone(), course);
    }

    let mut graph = Graph::<(String, i32), (), Undirected>::default();
    let mut node_indices = HashMap::new();

    // Corregido: eliminar '&' en el bucle
    for key in grouped_courses.keys() {
        let index = graph.add_node(key.clone());
        node_indices.insert(key.clone(), index);
    }

    let keys: Vec<(String, i32)> = grouped_courses.keys().cloned().collect();
    for i in 0..keys.len() {
        for j in (i + 1)..keys.len() {
            let key_i = keys[i].clone();
            let key_j = keys[j].clone();

            if !courses_overlap(grouped_courses[&key_i], grouped_courses[&key_j]) {
                let index_i = node_indices[&key_i];
                let index_j = node_indices[&key_j];
                graph.add_edge(index_i, index_j, ());
            }
        }
    }

    let mut cliques = Vec::new();
    let mut r = Vec::new();
    let mut p: HashSet<_> = graph.node_indices().collect();
    let mut x = HashSet::new();
    bron_kerbosch(&graph, &mut r, &mut p, &mut x, &mut cliques);

    let mut final_schedules = Vec::new();
    for clique in cliques {
        let mut schedule_group = Vec::new();
        let mut materias_incluidas = HashSet::new();

        for node_index in &clique {
            let key = graph[*node_index].clone();
            let course = grouped_courses[&key].clone();
            schedule_group.push(course.clone());
            materias_incluidas.insert(course.materia.nombre.clone());
        }

        if materias_incluidas.len() == course_names.len() {
            final_schedules.push(schedule_group);
        }
    }

    final_schedules
}

fn bron_kerbosch(
    graph: &Graph<(String, i32), (), Undirected>,
    r: &mut Vec<NodeIndex>,
    p: &mut HashSet<NodeIndex>,
    x: &mut HashSet<NodeIndex>,
    cliques: &mut Vec<Vec<NodeIndex>>,
) {
    if p.is_empty() && x.is_empty() {
        cliques.push(r.clone());
    } else {
        let mut p_vec: Vec<NodeIndex> = p.iter().cloned().collect();
        while let Some(v) = p_vec.pop() {
            r.push(v);
            let neighbors: HashSet<_> = graph.neighbors(v).collect();
            let mut p_new = p.intersection(&neighbors).cloned().collect();
            let mut x_new = x.intersection(&neighbors).cloned().collect();
            bron_kerbosch(graph, r, &mut p_new, &mut x_new, cliques);
            r.pop();
            p.remove(&v);
            x.insert(v);
        }
    }
}

fn courses_overlap(course1: &CourseSchedule, course2: &CourseSchedule) -> bool {
    for schedule1 in &course1.schedules {
        for schedule2 in &course2.schedules {
            if schedule1.dia == schedule2.dia {
                let start_time1 = parse_time(&schedule1.hora_inicio);
                let end_time1 = parse_time(&schedule1.hora_fin);
                let start_time2 = parse_time(&schedule2.hora_inicio);
                let end_time2 = parse_time(&schedule2.hora_fin);

                if let (Some(start_time1), Some(end_time1), Some(start_time2), Some(end_time2)) =
                    (start_time1, end_time1, start_time2, end_time2)
                {
                    if (start_time1 < end_time2) && (end_time1 > start_time2) {
                        return true;
                    }
                }
            }
        }
    }
    false
}

fn parse_time(time_str: &str) -> Option<NaiveTime> {
    NaiveTime::parse_from_str(time_str, "%H:%M:%S").ok()
        .or_else(|| NaiveTime::parse_from_str(time_str, "%H:%M").ok())
}

Cargo.toml
[package]
name = "backwellApi"
version = "0.1.0"
edition = "2021"

[dependencies]
actix-web = "4.3.1"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
reqwest = { version = "0.11", features = ["json", "rustls-tls"] }
tokio = { version = "1.30", features = ["macros", "rt-multi-thread"] }
chrono = { version = "0.4.27", features = ["serde"] }
petgraph = "0.6.5"
env_logger = "0.9"
log = "0.4"
url = "2.2.2"


SUGGESTIONS

**Summary:**

You've requested several improvements to your Rust application that interfaces with a Django API:

1. **Adjust the Django API Request:** Modify the request from Rust to Django to only retrieve the selected subjects, avoiding unnecessary data transfer.

2. **Handle Missing Subjects:** If some subjects are not found (due to typos or unavailability), return informative messages indicating which subjects were not found.

3. **Manage No Combination Scenarios:** If no schedule combinations are possible (due to overlapping times), handle this by either returning overlapped schedules with a message or providing individual schedules based on the `minimum` specified.

4. **Improve the Schedule Response Format:** Modify the `schedule_s` in the response to include detailed schedule information (day, start time, end time) in a more user-friendly format for the frontend.

5. **Change the Endpoint Path:** Update the endpoint path to `/v1/api/generate_schedule`.

Below, I've provided the updated code with explanations to address each of these points.

---

## **1. Adjust the Django API Request**

### **1.1 Modify the Request to Only Fetch Selected Subjects**

**Changes in `main.rs`:**

```rust
// Build the query parameters using 'materia__nombre__in'
if !req_body.courses.is_empty() {
    url.query_pairs_mut()
        .append_pair("materia__nombre__in", &req_body.courses.join(","));
}
```

**Explanation:**

- We're using the `materia__nombre__in` parameter to pass a comma-separated list of subjects.
- This ensures the Django API only returns courses for the selected subjects.
- Make sure your Django `CursoFilter` is updated to handle `materia__nombre__in`.

**Changes in Django (`filters.py`):**

```python
import django_filters
from .models import Curso

class CursoFilter(django_filters.FilterSet):
    materia__nombre__in = django_filters.BaseInFilter(field_name='materia__nombre')

    class Meta:
        model = Curso
        fields = ['materia__nombre__in']
```

---

## **2. Handle Missing Subjects**

### **2.1 Check for Missing Subjects and Return Messages**

**Changes in `main.rs`:**

```rust
// After receiving 'courses_data' from Django
let subjects_found: HashSet<String> = courses_data.iter()
    .map(|course| course.materia.nombre.trim().to_string())
    .collect();

let subjects_requested: HashSet<String> = req_body.courses.iter()
    .map(|s| s.trim().to_string())
    .collect();

let subjects_not_found: Vec<String> = subjects_requested.difference(&subjects_found).cloned().collect();

let mut messages = Vec::new();

if !subjects_not_found.is_empty() {
    messages.push(format!("Subjects not found: {}", subjects_not_found.join(", ")));
}
```

**Explanation:**

- We create sets of subjects found and subjects requested to identify any discrepancies.
- If any subjects are not found, we add a message to the `messages` vector.

---

## **3. Manage No Combination Scenarios**

### **3.1 Adjust Logic for No Possible Combinations**

**Changes in `main.rs`:**

```rust
let compatible_schedules = schedule_utils::create_compatible_schedules(
    &courses_data,
    &req_body.courses,
    req_body.minimum,
);

let mut final_schedules = compatible_schedules.clone();

if final_schedules.is_empty() {
    // No combinations found
    if req_body.minimum == 1 {
        // Return schedules with individual courses
        for course in &courses_data {
            final_schedules.push(vec![course.clone()]);
        }
        messages.push("No combinations possible, showing individual courses.".to_string());
    } else {
        // Return overlapping schedules (not possible)
        messages.push("No combinations possible with the requested minimum.".to_string());
    }
}
```

**Explanation:**

- If no compatible schedules are found, we check the `minimum` value.
- For `minimum == 1`, we provide schedules with individual courses.
- For higher minimums, we return an informative message.

---

## **4. Improve the Schedule Response Format**

### **4.1 Modify `simplify_schedules` Function**

**Changes in `main.rs`:**

```rust
fn simplify_schedules(schedules: &Vec<Vec<CourseSchedule>>) -> Vec<ScheduleGroup> {
    let mut result = Vec::new();

    for schedule_group in schedules {
        let mut courses_info = Vec::new();

        for course in schedule_group {
            let mut schedules_info = Vec::new();
            for sched in &course.schedules {
                schedules_info.push(ScheduleInfo {
                    dia: sched.dia.clone(),
                    hora_inicio: sched.hora_inicio.clone(),
                    hora_fin: sched.hora_fin.clone(),
                });
            }
            courses_info.push(CourseInfo {
                materia: course.materia.nombre.clone(),
                profesor: course.profesor.nombre.clone(),
                schedules: schedules_info,
            });
        }

        result.push(ScheduleGroup {
            courses: courses_info,
        });
    }

    result
}

#[derive(Serialize)]
struct GenerateScheduleResponse {
    response: u16,
    data: Vec<Vec<CourseSchedule>>,
    schedule_s: Vec<ScheduleGroup>,
    messages: Vec<String>,
}

#[derive(Serialize)]
struct ScheduleGroup {
    courses: Vec<CourseInfo>,
}

#[derive(Serialize)]
struct CourseInfo {
    materia: String,
    profesor: String,
    schedules: Vec<ScheduleInfo>,
}

#[derive(Serialize)]
struct ScheduleInfo {
    dia: String,
    hora_inicio: String,
    hora_fin: String,
}
```

**Explanation:**

- The `simplify_schedules` function now structures the schedule data in a clear, hierarchical format.
- This format includes detailed schedule information suitable for frontend display.

---

## **5. Change the Endpoint Path**

### **5.1 Update the Route in Actix Web**

**Changes in `main.rs`:**

```rust
HttpServer::new(|| {
    App::new()
        .route("/v1/api/generate_schedule", web::post().to(generate_schedule))
})
```

**Explanation:**

- The endpoint path is updated to `/v1/api/generate_schedule` as requested.

---

## **6. Full Updated `main.rs` Code**

```rust
use actix_web::{web, App, HttpServer, HttpResponse};
use serde::{Deserialize, Serialize};
use reqwest::Client;
use log::{info, error};
use std::collections::{HashMap, HashSet};
use std::env;
use url::Url;

mod schedule_utils;

#[derive(Deserialize)]
struct GenerateScheduleRequest {
    courses: Vec<String>,
    minimum: usize,
}

#[derive(Serialize)]
struct GenerateScheduleResponse {
    response: u16,
    data: Vec<Vec<CourseSchedule>>,
    schedule_s: Vec<ScheduleGroup>,
    messages: Vec<String>,
}

#[derive(Serialize)]
struct ScheduleGroup {
    courses: Vec<CourseInfo>,
}

#[derive(Serialize)]
struct CourseInfo {
    materia: String,
    profesor: String,
    schedules: Vec<ScheduleInfo>,
}

#[derive(Serialize)]
struct ScheduleInfo {
    dia: String,
    hora_inicio: String,
    hora_fin: String,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
struct CourseSchedule {
    // ... existing fields ...
}

// ... existing structs for Schedule, Materia, Profesor, Salon ...

async fn generate_schedule(req_body: web::Json<GenerateScheduleRequest>) -> impl actix_web::Responder {
    // ... existing code for building the Django API request ...

    // Check which subjects were found
    let subjects_found: HashSet<String> = courses_data.iter()
        .map(|course| course.materia.nombre.trim().to_string())
        .collect();

    let subjects_requested: HashSet<String> = req_body.courses.iter()
        .map(|s| s.trim().to_string())
        .collect();

    let subjects_not_found: Vec<String> = subjects_requested.difference(&subjects_found).cloned().collect();

    let mut messages = Vec::new();

    if !subjects_not_found.is_empty() {
        messages.push(format!("Subjects not found: {}", subjects_not_found.join(", ")));
    }

    // ... existing code for creating compatible schedules ...

    // Adjust logic for no possible combinations
    if final_schedules.is_empty() {
        if req_body.minimum == 1 {
            for course in &courses_data {
                final_schedules.push(vec![course.clone()]);
            }
            messages.push("No combinations possible, showing individual courses.".to_string());
        } else {
            messages.push("No combinations possible with the requested minimum.".to_string());
        }
    }

    let schedule_s = simplify_schedules(&final_schedules);

    let response = GenerateScheduleResponse {
        response: 200,
        data: final_schedules,
        schedule_s,
        messages,
    };

    HttpResponse::Ok().json(response)
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    env_logger::init();
    let port = 8082;
    info!("Starting server at http://0.0.0.0:{}", port);

    HttpServer::new(|| {
        App::new()
            .route("/v1/api/generate_schedule", web::post().to(generate_schedule))
    })
    .bind(("0.0.0.0", port))?
    .run()
    .await?;

    Ok(())
}
```

---

## **7. Additional Considerations**

### **7.1 Error Handling**

- Ensure that any errors during the request to the Django API are properly logged and returned.
- Handle potential parsing errors when dealing with time formats in schedules.

### **7.2 Frontend Compatibility**

- The new `schedule_s` structure is designed to be easily parsed and displayed by the frontend.
- Each course in the schedule includes detailed timing information.

### **7.3 Testing**

- Test the API with various inputs, including subjects that don't exist, to verify that messages are returned correctly.
- Check that when no combinations are possible, the API responds as expected based on the `minimum` value.

---

**Conclusion:**

The provided code updates address all the requested changes:

- **Efficient Data Retrieval:** By modifying the request to the Django API, only the selected subjects are fetched.

- **Informative Responses:** The API now returns messages when subjects are not found or when no schedule combinations are possible.

- **User-Friendly Schedule Data:** The `schedule_s` field in the response is structured for easy consumption by the frontend.

- **Endpoint Update:** The API endpoint has been changed to `/v1/api/generate_schedule`.

If you have further questions or need additional assistance, feel free to ask!


Check if the SUGGESTIONS are okay and send the complete code of the rust file to check it and test it with the django api.